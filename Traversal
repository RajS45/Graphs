BFS ans DFS Traversal. 
import java.util.*;
class Solution {
    private void dfs(int node, List<List<Integer>> adj, boolean[] vis, List<Integer> ans) {
        vis[node] = true;
        ans.add(node);
        // Normal for loop
        List<Integer> neighbors = adj.get(node);
        for (int j = 0; j < neighbors.size(); j++) {
            int neighbor = neighbors.get(j);
            if (!vis[neighbor]) {
                dfs(neighbor, adj, vis, ans);
            }
        }
    }

    public List<Integer> dfsOfGraph(int V, List<List<Integer>> adj) {
        boolean[] vis = new boolean[V];
        List<Integer> ans = new ArrayList<>();

        for (int i = 0; i < V; i++) {
            if (!vis[i]) {
                dfs(i, adj, vis, ans);
            }
        }

        return ans;
    }

    private void bfs(int node, List<List<Integer>> adj, boolean[] vis, List<Integer> ans) {
        Queue<Integer> q = new LinkedList<>();
        q.add(node);
        vis[node] = true;

        while (!q.isEmpty()) {
            int current = q.poll();
            ans.add(current);

            // Normal for loop
            List<Integer> neighbors = adj.get(current);
            for (int j = 0; j < neighbors.size(); j++) {
                int neighbor = neighbors.get(j);
                if (!vis[neighbor]) {
                    vis[neighbor] = true;
                    q.add(neighbor);
                }
            }
        }
    }

    public List<Integer> bfsOfGraph(int V, List<List<Integer>> adj) {
        boolean[] vis = new boolean[V];
        List<Integer> ans = new ArrayList<>();

        for (int i = 0; i < V; i++) {
            if (!vis[i]) {
                bfs(i, adj, vis, ans);
            }
        }

        return ans;
    }
}

class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        // Input number of vertices and edges
        System.out.print("Enter number of vertices: ");
        int V = sc.nextInt();

        System.out.print("Enter number of edges: ");
        int E = sc.nextInt();

        // Initialize adjacency list
        List<List<Integer>> adj = new ArrayList<>();
        for (int i = 0; i < V; i++) {
            adj.add(new ArrayList<>());
        }

        // Input edges
        System.out.println("Enter edges (u v):");
        for (int i = 0; i < E; i++) {
            int u = sc.nextInt();
            int v = sc.nextInt();
            adj.get(u).add(v);
            adj.get(v).add(u); // undirected graph
        }

        Solution sol = new Solution();

        List<Integer> bfs = sol.bfsOfGraph(V, adj);
        List<Integer> dfs = sol.dfsOfGraph(V, adj);

        System.out.println("The BFS traversal of the given graph is: " + bfs);
        System.out.println("The DFS traversal of the given graph is: " + dfs);

        sc.close();
    }
}
2.Connected Components.
import java.util.*;
class Solution {
    private static void bfs(int node, List<List<Integer>> adj, boolean[] vis) {
        Queue<Integer> q = new LinkedList<>();
        q.add(node);
        vis[node] = true;
        while (!q.isEmpty()) {
            int curr = q.poll();
            List<Integer> neighbors = adj.get(curr);
            for (int i = 0; i < neighbors.size(); i++) {
                int neighbor = neighbors.get(i);
                if (!vis[neighbor]) {
                    vis[neighbor] = true;
                    q.add(neighbor);
                }
            }
        }
    }
    public static int findNumberOfComponent(int V, List<List<Integer>> edges) {
        List<List<Integer>> adjLs = new ArrayList<>();
        for (int i = 0; i < V; i++) {
            adjLs.add(new ArrayList<>());
        }
        for (int i = 0; i < edges.size(); i++) {
            int u = edges.get(i).get(0);
            int v = edges.get(i).get(1);
            adjLs.get(u).add(v);
            adjLs.get(v).add(u);
        }
        boolean[] vis = new boolean[V];
        int cnt = 0;
        for (int i = 0; i < V; i++) {
            if (!vis[i]) {
                cnt++;
                bfs(i, adjLs, vis);
            }
        }
        return cnt;
    }
    public static void main(String []args){
        Scanner sc = new Scanner(System.in);
        int V = sc.nextInt();
        int E = sc.nextInt();
        List<List<Integer>>edges = new ArrayList<>();
        for(int i=0;i<E;i++){
            int u = sc.nextInt();
            int v = sc.nextInt();
            List<Integer>edge = new ArrayList<>();
            edge.add(u);
            edge.add(v);
            edges.add(edge);
        }
        int res = findNumberOfComponent(V , edges);
        System.out.println(res);
    }
}

3.Number of Provinces.
class Solution {
    public int numProvinces(int[][] adj) {
        int n = adj.length;
        List<List<Integer>> adjLs = new ArrayList<>();        
        for (int i = 0; i < n; i++) {
            adjLs.add(new ArrayList<>());
        }
        // Convert adjacency matrix to adjacency list
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (adj[i][j] == 1 && i != j) {
                    adjLs.get(i).add(j);
                    adjLs.get(j).add(i);
                }
            }
        }
        boolean[] vis = new boolean[n];
        int cnt = 0;
        // Count connected components
        for (int i = 0; i < n; i++) {
            if (!vis[i]) {
                cnt++;
                bfs(i, adjLs, vis);
            }
        }
        return cnt;
    }
    public void bfs(int node, List<List<Integer>> adj, boolean[] vis) {
        Queue<Integer> q = new LinkedList<>();
        q.add(node);
        vis[node] = true;
        while (!q.isEmpty()) {
            int curr = q.poll();
            for (int i = 0; i < adj.get(curr).size(); i++) {
                int adjNode = adj.get(curr).get(i);
                if (!vis[adjNode]) {
                    vis[adjNode] = true;
                    q.add(adjNode);
                }
            }
        }
    }
}
4.Number of IsLand.
class Solution {
    private boolean isValid(int i, int j, 
                            int n, int m) {           
        if (i < 0 || i >= n) return false;
        if (j < 0 || j >= m) return false;        
        return true;
    }
    private void bfs(int i, int j, boolean[][] vis, 
                     char[][] grid) {                         
        vis[i][j] = true;        
        Queue<int[]> q = new LinkedList<>();        
        q.add(new int[]{i, j});         
        int n = grid.length; 
        int m = grid[0].length;       
        while (!q.isEmpty()) {
            int[] cell = q.poll();            
            int row = cell[0];
            int col = cell[1];            
            for (int delRow = -1; delRow <= 1; delRow++) {
                for (int delCol = -1; delCol <= 1; delCol++) {
                    int newRow = row + delRow;
                    int newCol = col + delCol;
                    if (isValid(newRow, newCol, n, m) 
                        && grid[newRow][newCol] == '1' 
                        && !vis[newRow][newCol]) {                            
                        vis[newRow][newCol] = true;                        
                        q.add(new int[]{newRow, newCol});
                    }
                }
            }
        }
    }    
    public int numIslands(char[][] grid) {
        int n = grid.length;
        int m = grid[0].length;        
        boolean[][] vis = new boolean[n][m];        
        int count = 0;        
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (!vis[i][j] && grid[i][j] == '1') {
                    count++; 
                    bfs(i, j, vis, grid);        
                }
            }
        }
        return count;
    }
    public static void main(String []args){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        char [][]grid = new char[n][m];
        for(int i =0;i<n;i++){
            for(int j=0;j<m;j++){
                grid[i][j] = sc.next().charAt(0);
            }
        }
        Solution sol = new Solution();
        int r = sol.numIslands(grid);
        System.out.println(r);
    }
}
5.Number of Enclaves.
import java.util.*;

class Solution {
    private int[] delRow = {-1, 0, 1, 0};
    private int[] delCol = {0, 1, 0, -1};
    
    private boolean isValid(int i, int j, int n, int m) {
        return !(i < 0 || i >= n || j < 0 || j >= m);
    }
    
    private void bfs(int[][] grid, Queue<int[]> q, boolean[][] vis) {
        int n = grid.length;
        int m = grid[0].length; 
        
        while(!q.isEmpty()) {
            int[] cell = q.poll();
            int row = cell[0];
            int col = cell[1];
            
            for(int i=0; i < 4; i++) {
                int nRow = row + delRow[i]; 
                int nCol = col + delCol[i]; 
                
                if(isValid(nRow, nCol, n, m) && 
                   grid[nRow][nCol] == 1 
                   && !vis[nRow][nCol]) {
                    
                    vis[nRow][nCol] = true;
                    q.add(new int[]{nRow, nCol});
                }
            }
        }
    }
    
    public int numberOfEnclaves(int[][] grid) {
        int n = grid.length;
        int m = grid[0].length;
        Queue<int[]> q = new LinkedList<>();
        boolean[][] vis = new boolean[n][m];
        
        for(int i=0; i < n; i++) {
            for(int j=0; j < m; j++) {
                if((i == 0 || i == n-1 || j == 0 || j == m-1) &&
                    grid[i][j] == 1) {
                    
                    vis[i][j] = true;
                    q.add(new int[]{i, j});
                }
            }
        }
       
        bfs(grid, q, vis);
        
        int count = 0;
        for(int i=0; i < n; i++) {
            for(int j=0; j < m; j++){
                if(grid[i][j] == 1 && !vis[i][j])
                    count++;
            }
        }
        
        return count;
    }
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        System.out.print("Enter number of rows: ");
        int n = sc.nextInt();
        System.out.print("Enter number of columns: ");
        int m = sc.nextInt();
        
        int[][] grid = new int[n][m];
        System.out.println("Enter the grid values (0 for water, 1 for land):");
        for(int i=0; i<n; i++) {
            for(int j=0; j<m; j++) {
                grid[i][j] = sc.nextInt();
            }
        }
        
        Solution sol = new Solution(); 
        int ans = sol.numberOfEnclaves(grid);
        System.out.println("The number of enclaves in given grid are: " + ans);
        
        sc.close();
    }
}
